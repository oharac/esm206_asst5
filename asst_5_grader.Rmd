---
title: "Untitled"
author: "Casey O'Hara"
date: "11/27/2021"
output: html_document
---

```{r setup, include=TRUE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

library(tidyverse)
library(git2r)
library(here)
library(magrittr) ### for %$% pipe...

```

# Setup

## Read and clean repo names; create directories

Manually downloaded the .csv of partners and repo links and saved in the project root dir as `asst_5_partners.csv`.

```{r}

### Read-in all repo names
repos <- read_csv(here('asst_5_partners.csv'), skip = 2) %>%
  janitor::clean_names() %>%
  distinct() %>%
  gather(task, repo, ends_with('repo_link')) %>%
  mutate(dir = basename(repo),
         dir = str_remove(dir, '.git$'),
         dir = str_replace(dir, 'ej-screen', 'ejscreen'),
         dir = str_replace(dir, '--', '-'),
         dir = here('asst_5_repos', dir))

### Create directories, unless they already exist
if(any(!dir.exists(repos$dir))) {
  message('creating directories for repos')
  tmp <- lapply(repos$dir, dir.create)
}
```

## Clone the repositories

Clone repos, unless they have already been cloned - in the `clone()` function, leaving `credentials = NULL` I believe will work fine as long as you've got your PAT all set up.

```{r}
urls <- repos$repo
dirs <- repos$dir

tmp <- lapply(seq_along(urls), FUN = function(i) {
  fs <- list.files(dirs[i])
  if(dir.exists(file.path(dirs[i], '.git'))) {
    ### check for existing repo; if already a repo, report contents
    fs <- list.files(dirs[i])
    message('Directory ', basename(dirs[i]), ' is a .git repository and contains: \n', 
            paste0('.../', fs, collapse = '\n'))
  } else {
    ### no existing repo? then clone it
    message('Cloning ', urls[i], ' to ', basename(dirs[i]), '...')
    clone(urls[i], dirs[i])
  }
})
```

## Identify Rmd files

``` {r}
rmds <- lapply(repos$dir, FUN = function(d) {
  fs <- list.files(d, pattern = '.Rmd$', 
                   recursive = TRUE, full.names = TRUE, ignore.case = TRUE)
  if(length(fs) == 0) fs <- 'NO RMD DETECTED!'
  df <- data.frame(dir = d, 
                   rmd = fs)
}) %>%
  bind_rows()

repos_rmds <- repos %>%
  left_join(rmds, by = 'dir')
```

Also, place a text file in the repo notifying that the repo is being graded.  Does this actually commit/push?  probably not if I'm not invited as a collaborator... skip it

``` {r, eval = FALSE}
# Add a text file telling people that I will be grading them - is this working?
notify <- function(dir){
  message('Notifying ', basename(dir))
  f <- file.path(dir, 'grading.txt')
  if(file.exists(f)) {
    message('Already notified: ', f)
    return(invisible(NULL))
  }
  file.create(f)
  cat('Your repo has been graded!', file = f)
  add(repo = dir, 'grading.txt')
  commit(dir, message = 'grading the repo')
  push(dir)
}

safely_notify <- safely(notify)

notifications <- lapply(repos$dir, safely_notify)
```

# General checks

## Who didn't store their rmd file in the src folder?

Looks like the assignment wasn't super explicit about this - it says to create a `src` folder but not explicitly to put the `.Rmd` in it...

```{r}
rmd_not_in_src <- repos_rmds %>%
  filter(!str_detect(rmd, 'src'))
```

## Task 2

### How many commit messages per user?
``` {r}
### helper functions:
get_commits <- function(dir) {
  dir_commits <- git2r::commits(dir) %>%
    purrr::map_dfr(tabulize)
  return(dir_commits)
}

tabulize <- function(commit) {
  tibble::tibble(
    SHA  = commit$sha,
    user = commit$author$name,
    date = lubridate::as_datetime(commit$author$when$time)
  )
}

task_2_commits <- repos_rmds %>%
  filter(str_detect(dir, 'ejscreen')) %>%      # Filter for task 2
  mutate(results = map(dir, get_commits)) %>%  # Get commit history of each repo
  unnest(results) %>%                          # Format
  count(repo, user) %>%                        # Count individual commits
  filter(!user == 'GitHub')

## Did anyone have fewer than 2 commits?
less_than_2_t2 <- task_2_commits %>%
  filter(n < 2)

DT::datatable(task_2_commits)
```


### Does it render?

For this, make sure to put a `data/ces3demographics.csv` in the project root folder so `here()` will properly find it!

```{r drop all htmls, eval = FALSE}
htmls <- list.files(here('asst_5_repos'), pattern = '.html$',
                    recursive = TRUE, full.names = TRUE)
unlink(htmls)
```


``` {r}
safely_render <- safely(rmarkdown::render)

# Render task 2
results_task_2 <- repos_rmds %>%
  filter(str_detect(dir, 'ejscreen')) %>%                                       
    # Filter for task 2
  mutate(run = map(rmd, safely_render, quiet = T, knit_root_dir = dir)) %>%   
    # Safely render
  unnest_wider(run) %>%
    # Unnest the weird list
  select(gp = group_number, p1f = partner_1, p1l = x3, p2f = partner_2, p2l = x5, 
         rmd, result, error)

DT::datatable(results_task_2)
```

## TASK 3

### How many commit messages per user?
``` {r}
task_3_commits <- repos %>%
  filter(str_detect(dir, 'grad')) %>%
  mutate(results = map(dir, get_commits)) %>%
  unnest(results) %>%
  group_by(repo, user) %>%
  count() %>%
  filter(!user == 'GitHub')

## Did anyone have fewer than 2 commits?
less_than_2_t3 <- task_3_commits %>%
  filter(n < 2)

DT::datatable(task_3_commits)
```

### Does it render?

Similar here: make sure there is a `data/ucsb_grad_data.csv` file in the project root.
``` {r}
# Render task 3
results_task_3 <- repos_rmds %>%
  filter(str_detect(dir, 'grad')) %>%
  mutate(run = map(rmd, safely_render, quiet = T)) %>%
  unnest_wider(run) %>%
  select(gp = group_number, p1f = partner_1, p1l = x3, p2f = partner_2, p2l = x5, 
         rmd, result, error)

DT::datatable(results_task_3)
```


# Clean everything up

This deletes all repos! only run after grading and before pushing the script

``` {r, eval = FALSE}

# unlink(repos_rmds$dir, force = TRUE, recursive = TRUE)

```

